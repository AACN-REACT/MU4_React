/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.1.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * Gets a Media Management View Model
   * @return Success
   */
  getMediaManagementVm(version: string): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/MediaManagement";
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetMediaManagementVm(_response);
    });
  }

  protected processGetMediaManagementVm(
    response: Response
  ): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        let result500: any = null;
        let resultData500 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = MediaManagementVmQueryResponseWrapper.fromJS(resultData500);
        return throwException(
          "Server Error",
          status,
          _responseText,
          _headers,
          result500
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        let resultData404 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = MediaManagementVmQueryResponseWrapper.fromJS(resultData404);
        return throwException(
          "Not Found",
          status,
          _responseText,
          _headers,
          result404
        );
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Start Upload (add a new media upload)
   * @param key Media Key
   * @param username (optional)
   * @param file (optional)
   * @return Success
   */
  startUpload(
    key: string,
    username: string | null | undefined,
    version: string,
    file: FileParameter | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (username !== undefined && username !== null)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      content_.append(
        "file",
        file.data,
        file.fileName ? file.fileName : "file"
      );

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStartUpload(_response);
    });
  }

  protected processStartUpload(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Deletes a Media
   * @param key Media Key
   * @param username (optional)
   * @return Success
   */
  remove(
    key: string,
    username: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (username !== undefined && username !== null)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRemove(_response);
    });
  }

  protected processRemove(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Adds a Media Keyword
   * @param key Media Key
   * @param keyword (optional) Media keyword
   * @param username (optional)
   * @return Success
   */
  addKeyword(
    key: string,
    keyword: string | null | undefined,
    username: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}/keywords?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (keyword !== undefined && keyword !== null)
      url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
    if (username !== undefined && username !== null)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAddKeyword(_response);
    });
  }

  protected processAddKeyword(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Removes a Media Keyword
   * @param key Media Key
   * @param keyword (optional)
   * @param username (optional)
   * @return Success
   */
  removeKeyword(
    key: string,
    keyword: string | null | undefined,
    username: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}/keywords?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (keyword !== undefined && keyword !== null)
      url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
    if (username !== undefined && username !== null)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRemoveKeyword(_response);
    });
  }

  protected processRemoveKeyword(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Updates the Media Title
   * @param key Media Key
   * @param title (optional) Media Title
   * @param username (optional)
   * @return Success
   */
  updateTitle(
    key: string,
    title: string | null | undefined,
    username: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}/title?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (title !== undefined && title !== null)
      url_ += "title=" + encodeURIComponent("" + title) + "&";
    if (username !== undefined && username !== null)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "PUT",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateTitle(_response);
    });
  }

  protected processUpdateTitle(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Updates the Media Status
   * @param key Media key
   * @param status (optional) Status (examples: Finalized, Failed, Complete, Started
   * @param username (optional)
   * @return Success
   */
  updateStatus(
    key: string,
    status: string | null | undefined,
    username: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}/Status?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&";
    if (username !== undefined && username !== null)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "PUT",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateStatus(_response);
    });
  }

  protected processUpdateStatus(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Allows Stakeholders to Finalize Media
   * @param username (optional)
   * @return Success
   */
  stakeholderFinalizeMedia(
    key: string,
    username: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ =
      this.baseUrl + "/api/v{version}/Medias/{key}/stakeholderfinalization?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (username !== undefined && username !== null)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "PUT",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStakeholderFinalizeMedia(_response);
    });
  }

  protected processStakeholderFinalizeMedia(
    response: Response
  ): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Updates the Media NetforumItemLink
   * @param netforumKey (optional)
   * @param type (optional)
   * @return Success
   */
  updateNetforumItemLink(
    key: string,
    netforumKey: string | undefined,
    type: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}/netforumItemLink?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (netforumKey === null)
      throw new Error("The parameter 'netforumKey' cannot be null.");
    else if (netforumKey !== undefined)
      url_ += "netforumKey=" + encodeURIComponent("" + netforumKey) + "&";
    if (type !== undefined && type !== null)
      url_ += "type=" + encodeURIComponent("" + type) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "PUT",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateNetforumItemLink(_response);
    });
  }

  protected processUpdateNetforumItemLink(
    response: Response
  ): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Updates a Media LinkToNetforumItem
   * @param netforumKey (optional)
   * @return Success
   */
  linkToNetforumItem(
    key: string,
    netforumKey: string | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}/netforumItemLink?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (netforumKey === null)
      throw new Error("The parameter 'netforumKey' cannot be null.");
    else if (netforumKey !== undefined)
      url_ += "netforumKey=" + encodeURIComponent("" + netforumKey) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLinkToNetforumItem(_response);
    });
  }

  protected processLinkToNetforumItem(
    response: Response
  ): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Get's Media GetNetforumItemLink
   * @param type (optional)
   * @return Success
   */
  getNetforumItemLink(
    key: string,
    type: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}/netforumItemLink?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (type !== undefined && type !== null)
      url_ += "type=" + encodeURIComponent("" + type) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetNetforumItemLink(_response);
    });
  }

  protected processGetNetforumItemLink(
    response: Response
  ): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Gets a Media Details View
   * @return Success
   */
  getMediaDetailsVm(key: string, version: string): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/Medias/{key}/MediaDetailsVm";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetMediaDetailsVm(_response);
    });
  }
//media details
  protected processGetMediaDetailsVm(
    response: Response
  ): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }

  /**
   * Gets a netforum item
   * @param type (optional)
   * @return Success
   */
  getNetforumItem(
    key: string,
    type: string | null | undefined,
    version: string
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v{version}/NetforumItem/{key}?";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    if (type !== undefined && type !== null)
      url_ += "type=" + encodeURIComponent("" + type) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetNetforumItem(_response);
    });
  }

  protected processGetNetforumItem(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException(
          "Bad Request",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 406) {
      return response.text().then((_responseText) => {
        let result406: any = null;
        let resultData406 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result406 = ProblemDetails.fromJS(resultData406);
        return throwException(
          "Not Acceptable",
          status,
          _responseText,
          _headers,
          result406
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException("Server Error", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        let resultData401 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException(
          "Unauthorized",
          status,
          _responseText,
          _headers,
          result401
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 201) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else {
      return response.text().then((_responseText) => {
        let resultdefault: any = null;
        let resultDatadefault =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        resultdefault = ProblemDetails.fromJS(resultDatadefault);
        return throwException(
          "Error",
          status,
          _responseText,
          _headers,
          resultdefault
        );
      });
    }
  }
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.title = _data["title"];
      this.status = _data["status"];
      this.detail = _data["detail"];
      this.instance = _data["instance"];
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === "object" ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["title"] = this.title;
    data["status"] = this.status;
    data["detail"] = this.detail;
    data["instance"] = this.instance;
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
}

export class MediaManagementNetforumItemInfo
  implements IMediaManagementNetforumItemInfo {
  netforumKey?: string;
  netforumType?: string | undefined;

  constructor(data?: IMediaManagementNetforumItemInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.netforumKey = _data["NetforumKey"];
      this.netforumType = _data["NetforumType"];
    }
  }

  static fromJS(data: any): MediaManagementNetforumItemInfo {
    data = typeof data === "object" ? data : {};
    let result = new MediaManagementNetforumItemInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["NetforumKey"] = this.netforumKey;
    data["NetforumType"] = this.netforumType;
    return data;
  }
}

export interface IMediaManagementNetforumItemInfo {
  netforumKey?: string;
  netforumType?: string | undefined;
}

export class MediaManagementDetailsDto implements IMediaManagementDetailsDto {
  key?: string;
  startDateTime?: Date;
  startedByUsername?: string | undefined;
  status?: string | undefined;
  originalFileName?: string | undefined;
  title?: string | undefined;
  keywords?: string[] | undefined;
  mediaHostUrl?: string | undefined;
  netforumItemLink?: MediaManagementNetforumItemInfo;
  finalizedDateTime?: Date;
  canEdit?: boolean;
  isProcessing?: boolean;

  constructor(data?: IMediaManagementDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data["Key"];
      this.startDateTime = _data["StartDateTime"]
        ? new Date(_data["StartDateTime"].toString())
        : <any>undefined;
      this.startedByUsername = _data["StartedByUsername"];
      this.status = _data["Status"];
      this.originalFileName = _data["OriginalFileName"];
      this.title = _data["Title"];
      if (Array.isArray(_data["Keywords"])) {
        this.keywords = [] as any;
        for (let item of _data["Keywords"]) this.keywords!.push(item);
      }
      this.mediaHostUrl = _data["MediaHostUrl"];
      this.netforumItemLink = _data["NetforumItemLink"]
        ? MediaManagementNetforumItemInfo.fromJS(_data["NetforumItemLink"])
        : <any>undefined;
      this.finalizedDateTime = _data["FinalizedDateTime"]
        ? new Date(_data["FinalizedDateTime"].toString())
        : <any>undefined;
      this.canEdit = _data["CanEdit"];
      this.isProcessing = _data["IsProcessing"];
    }
  }

  static fromJS(data: any): MediaManagementDetailsDto {
    data = typeof data === "object" ? data : {};
    let result = new MediaManagementDetailsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Key"] = this.key;
    data["StartDateTime"] = this.startDateTime
      ? this.startDateTime.toISOString()
      : <any>undefined;
    data["StartedByUsername"] = this.startedByUsername;
    data["Status"] = this.status;
    data["OriginalFileName"] = this.originalFileName;
    data["Title"] = this.title;
    if (Array.isArray(this.keywords)) {
      data["Keywords"] = [];
      for (let item of this.keywords) data["Keywords"].push(item);
    }
    data["MediaHostUrl"] = this.mediaHostUrl;
    data["NetforumItemLink"] = this.netforumItemLink
      ? this.netforumItemLink.toJSON()
      : <any>undefined;
    data["FinalizedDateTime"] = this.finalizedDateTime
      ? this.finalizedDateTime.toISOString()
      : <any>undefined;
    data["CanEdit"] = this.canEdit;
    data["IsProcessing"] = this.isProcessing;
    return data;
  }
}

export interface IMediaManagementDetailsDto {
  key?: string;
  startDateTime?: Date;
  startedByUsername?: string | undefined;
  status?: string | undefined;
  originalFileName?: string | undefined;
  title?: string | undefined;
  keywords?: string[] | undefined;
  mediaHostUrl?: string | undefined;
  netforumItemLink?: MediaManagementNetforumItemInfo;
  finalizedDateTime?: Date;
  canEdit?: boolean;
  isProcessing?: boolean;
}

export class MediaManagementVm implements IMediaManagementVm {
  finalizedMediaDetailsDtos?: MediaManagementDetailsDto[] | undefined;
  pendingMediaDetailsDto?: MediaManagementDetailsDto[] | undefined;

  constructor(data?: IMediaManagementVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["FinalizedMediaDetailsDtos"])) {
        this.finalizedMediaDetailsDtos = [] as any;
        for (let item of _data["FinalizedMediaDetailsDtos"])
          this.finalizedMediaDetailsDtos!.push(
            MediaManagementDetailsDto.fromJS(item)
          );
      }
      if (Array.isArray(_data["PendingMediaDetailsDto"])) {
        this.pendingMediaDetailsDto = [] as any;
        for (let item of _data["PendingMediaDetailsDto"])
          this.pendingMediaDetailsDto!.push(
            MediaManagementDetailsDto.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): MediaManagementVm {
    data = typeof data === "object" ? data : {};
    let result = new MediaManagementVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.finalizedMediaDetailsDtos)) {
      data["FinalizedMediaDetailsDtos"] = [];
      for (let item of this.finalizedMediaDetailsDtos)
        data["FinalizedMediaDetailsDtos"].push(item.toJSON());
    }
    if (Array.isArray(this.pendingMediaDetailsDto)) {
      data["PendingMediaDetailsDto"] = [];
      for (let item of this.pendingMediaDetailsDto)
        data["PendingMediaDetailsDto"].push(item.toJSON());
    }
    return data;
  }
}

export interface IMediaManagementVm {
  finalizedMediaDetailsDtos?: MediaManagementDetailsDto[] | undefined;
  pendingMediaDetailsDto?: MediaManagementDetailsDto[] | undefined;
}

export class ErrorInfo implements IErrorInfo {
  userErrorMessage?: string | undefined;

  constructor(data?: IErrorInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userErrorMessage = _data["UserErrorMessage"];
    }
  }

  static fromJS(data: any): ErrorInfo {
    data = typeof data === "object" ? data : {};
    let result = new ErrorInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["UserErrorMessage"] = this.userErrorMessage;
    return data;
  }
}

export interface IErrorInfo {
  userErrorMessage?: string | undefined;
}

export class StringStringKeyValuePair implements IStringStringKeyValuePair {
  readonly key?: string | undefined;
  readonly value?: string | undefined;

  constructor(data?: IStringStringKeyValuePair) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).key = _data["Key"];
      (<any>this).value = _data["Value"];
    }
  }

  static fromJS(data: any): StringStringKeyValuePair {
    data = typeof data === "object" ? data : {};
    let result = new StringStringKeyValuePair();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Key"] = this.key;
    data["Value"] = this.value;
    return data;
  }
}

export interface IStringStringKeyValuePair {
  key?: string | undefined;
  value?: string | undefined;
}

export class MediaManagementVmQueryResponseWrapper
  implements IMediaManagementVmQueryResponseWrapper {
  result?: MediaManagementVm;
  errorInfo?: ErrorInfo;
  errors?: StringStringKeyValuePair[] | undefined;

  constructor(data?: IMediaManagementVmQueryResponseWrapper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data["Result"]
        ? MediaManagementVm.fromJS(_data["Result"])
        : <any>undefined;
      this.errorInfo = _data["ErrorInfo"]
        ? ErrorInfo.fromJS(_data["ErrorInfo"])
        : <any>undefined;
      if (Array.isArray(_data["Errors"])) {
        this.errors = [] as any;
        for (let item of _data["Errors"])
          this.errors!.push(StringStringKeyValuePair.fromJS(item));
      }
    }
  }

  static fromJS(data: any): MediaManagementVmQueryResponseWrapper {
    data = typeof data === "object" ? data : {};
    let result = new MediaManagementVmQueryResponseWrapper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
    data["ErrorInfo"] = this.errorInfo
      ? this.errorInfo.toJSON()
      : <any>undefined;
    if (Array.isArray(this.errors)) {
      data["Errors"] = [];
      for (let item of this.errors) data["Errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface IMediaManagementVmQueryResponseWrapper {
  result?: MediaManagementVm;
  errorInfo?: ErrorInfo;
  errors?: StringStringKeyValuePair[] | undefined;
}

export class BooleanCommandResponseWrapper
  implements IBooleanCommandResponseWrapper {
  result?: boolean;
  errors?: StringStringKeyValuePair[] | undefined;
  warnings?: StringStringKeyValuePair[] | undefined;
  errorInfo?: ErrorInfo;

  constructor(data?: IBooleanCommandResponseWrapper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data["Result"];
      if (Array.isArray(_data["Errors"])) {
        this.errors = [] as any;
        for (let item of _data["Errors"])
          this.errors!.push(StringStringKeyValuePair.fromJS(item));
      }
      if (Array.isArray(_data["Warnings"])) {
        this.warnings = [] as any;
        for (let item of _data["Warnings"])
          this.warnings!.push(StringStringKeyValuePair.fromJS(item));
      }
      this.errorInfo = _data["ErrorInfo"]
        ? ErrorInfo.fromJS(_data["ErrorInfo"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): BooleanCommandResponseWrapper {
    data = typeof data === "object" ? data : {};
    let result = new BooleanCommandResponseWrapper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Result"] = this.result;
    if (Array.isArray(this.errors)) {
      data["Errors"] = [];
      for (let item of this.errors) data["Errors"].push(item.toJSON());
    }
    if (Array.isArray(this.warnings)) {
      data["Warnings"] = [];
      for (let item of this.warnings) data["Warnings"].push(item.toJSON());
    }
    data["ErrorInfo"] = this.errorInfo
      ? this.errorInfo.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IBooleanCommandResponseWrapper {
  result?: boolean;
  errors?: StringStringKeyValuePair[] | undefined;
  warnings?: StringStringKeyValuePair[] | undefined;
  errorInfo?: ErrorInfo;
}

export class BooleanQueryResponseWrapper
  implements IBooleanQueryResponseWrapper {
  result?: boolean;
  errorInfo?: ErrorInfo;
  errors?: StringStringKeyValuePair[] | undefined;

  constructor(data?: IBooleanQueryResponseWrapper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data["Result"];
      this.errorInfo = _data["ErrorInfo"]
        ? ErrorInfo.fromJS(_data["ErrorInfo"])
        : <any>undefined;
      if (Array.isArray(_data["Errors"])) {
        this.errors = [] as any;
        for (let item of _data["Errors"])
          this.errors!.push(StringStringKeyValuePair.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BooleanQueryResponseWrapper {
    data = typeof data === "object" ? data : {};
    let result = new BooleanQueryResponseWrapper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Result"] = this.result;
    data["ErrorInfo"] = this.errorInfo
      ? this.errorInfo.toJSON()
      : <any>undefined;
    if (Array.isArray(this.errors)) {
      data["Errors"] = [];
      for (let item of this.errors) data["Errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBooleanQueryResponseWrapper {
  result?: boolean;
  errorInfo?: ErrorInfo;
  errors?: StringStringKeyValuePair[] | undefined;
}

export class NetforumItemInfo implements INetforumItemInfo {
  netforumKey?: string;
  netforumType?: string | undefined;

  constructor(data?: INetforumItemInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.netforumKey = _data["NetforumKey"];
      this.netforumType = _data["NetforumType"];
    }
  }

  static fromJS(data: any): NetforumItemInfo {
    data = typeof data === "object" ? data : {};
    let result = new NetforumItemInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["NetforumKey"] = this.netforumKey;
    data["NetforumType"] = this.netforumType;
    return data;
  }
}

export interface INetforumItemInfo {
  netforumKey?: string;
  netforumType?: string | undefined;
}

export class MediaAuditDto implements IMediaAuditDto {
  dateTime?: Date;
  key?: string;
  action?: string | undefined;
  notes?: string | undefined;
  username?: string | undefined;

  constructor(data?: IMediaAuditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dateTime = _data["DateTime"]
        ? new Date(_data["DateTime"].toString())
        : <any>undefined;
      this.key = _data["Key"];
      this.action = _data["Action"];
      this.notes = _data["Notes"];
      this.username = _data["Username"];
    }
  }

  static fromJS(data: any): MediaAuditDto {
    data = typeof data === "object" ? data : {};
    let result = new MediaAuditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["DateTime"] = this.dateTime
      ? this.dateTime.toISOString()
      : <any>undefined;
    data["Key"] = this.key;
    data["Action"] = this.action;
    data["Notes"] = this.notes;
    data["Username"] = this.username;
    return data;
  }
}

export interface IMediaAuditDto {
  dateTime?: Date;
  key?: string;
  action?: string | undefined;
  notes?: string | undefined;
  username?: string | undefined;
}

export class MediaDetailsVm implements IMediaDetailsVm {
  key?: string;
  startDateTime?: Date;
  startedByUsername?: string | undefined;
  status?: string | undefined;
  originalFileName?: string | undefined;
  title?: string | undefined;
  keywords?: string[] | undefined;
  mediaHostUrl?: string | undefined;
  netforumItemLink?: NetforumItemInfo;
  mediaAudits?: MediaAuditDto[] | undefined;
  finalizedDateTime?: Date | undefined;
  canEdit?: boolean;
  isProcessing?: boolean;

  constructor(data?: IMediaDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data["Key"];
      this.startDateTime = _data["StartDateTime"]
        ? new Date(_data["StartDateTime"].toString())
        : <any>undefined;
      this.startedByUsername = _data["StartedByUsername"];
      this.status = _data["Status"];
      this.originalFileName = _data["OriginalFileName"];
      this.title = _data["Title"];
      if (Array.isArray(_data["Keywords"])) {
        this.keywords = [] as any;
        for (let item of _data["Keywords"]) this.keywords!.push(item);
      }
      this.mediaHostUrl = _data["MediaHostUrl"];
      this.netforumItemLink = _data["NetforumItemLink"]
        ? NetforumItemInfo.fromJS(_data["NetforumItemLink"])
        : <any>undefined;
      if (Array.isArray(_data["MediaAudits"])) {
        this.mediaAudits = [] as any;
        for (let item of _data["MediaAudits"])
          this.mediaAudits!.push(MediaAuditDto.fromJS(item));
      }
      this.finalizedDateTime = _data["FinalizedDateTime"]
        ? new Date(_data["FinalizedDateTime"].toString())
        : <any>undefined;
      this.canEdit = _data["CanEdit"];
      this.isProcessing = _data["IsProcessing"];
    }
  }

  static fromJS(data: any): MediaDetailsVm {
    data = typeof data === "object" ? data : {};
    let result = new MediaDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Key"] = this.key;
    data["StartDateTime"] = this.startDateTime
      ? this.startDateTime.toISOString()
      : <any>undefined;
    data["StartedByUsername"] = this.startedByUsername;
    data["Status"] = this.status;
    data["OriginalFileName"] = this.originalFileName;
    data["Title"] = this.title;
    if (Array.isArray(this.keywords)) {
      data["Keywords"] = [];
      for (let item of this.keywords) data["Keywords"].push(item);
    }
    data["MediaHostUrl"] = this.mediaHostUrl;
    data["NetforumItemLink"] = this.netforumItemLink
      ? this.netforumItemLink.toJSON()
      : <any>undefined;
    if (Array.isArray(this.mediaAudits)) {
      data["MediaAudits"] = [];
      for (let item of this.mediaAudits)
        data["MediaAudits"].push(item.toJSON());
    }
    data["FinalizedDateTime"] = this.finalizedDateTime
      ? this.finalizedDateTime.toISOString()
      : <any>undefined;
    data["CanEdit"] = this.canEdit;
    data["IsProcessing"] = this.isProcessing;
    return data;
  }
}

export interface IMediaDetailsVm {
  key?: string;
  startDateTime?: Date;
  startedByUsername?: string | undefined;
  status?: string | undefined;
  originalFileName?: string | undefined;
  title?: string | undefined;
  keywords?: string[] | undefined;
  mediaHostUrl?: string | undefined;
  netforumItemLink?: NetforumItemInfo;
  mediaAudits?: MediaAuditDto[] | undefined;
  finalizedDateTime?: Date | undefined;
  canEdit?: boolean;
  isProcessing?: boolean;
}

export class MediaDetailsVmQueryResponseWrapper
  implements IMediaDetailsVmQueryResponseWrapper {
  result?: MediaDetailsVm;
  errorInfo?: ErrorInfo;
  errors?: StringStringKeyValuePair[] | undefined;

  constructor(data?: IMediaDetailsVmQueryResponseWrapper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data["Result"]
        ? MediaDetailsVm.fromJS(_data["Result"])
        : <any>undefined;
      this.errorInfo = _data["ErrorInfo"]
        ? ErrorInfo.fromJS(_data["ErrorInfo"])
        : <any>undefined;
      if (Array.isArray(_data["Errors"])) {
        this.errors = [] as any;
        for (let item of _data["Errors"])
          this.errors!.push(StringStringKeyValuePair.fromJS(item));
      }
    }
  }

  static fromJS(data: any): MediaDetailsVmQueryResponseWrapper {
    data = typeof data === "object" ? data : {};
    let result = new MediaDetailsVmQueryResponseWrapper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
    data["ErrorInfo"] = this.errorInfo
      ? this.errorInfo.toJSON()
      : <any>undefined;
    if (Array.isArray(this.errors)) {
      data["Errors"] = [];
      for (let item of this.errors) data["Errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface IMediaDetailsVmQueryResponseWrapper {
  result?: MediaDetailsVm;
  errorInfo?: ErrorInfo;
  errors?: StringStringKeyValuePair[] | undefined;
}

export class NetforumItemVm implements INetforumItemVm {
  netforumKey?: string;
  netforumType?: string | undefined;

  constructor(data?: INetforumItemVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.netforumKey = _data["NetforumKey"];
      this.netforumType = _data["NetforumType"];
    }
  }

  static fromJS(data: any): NetforumItemVm {
    data = typeof data === "object" ? data : {};
    let result = new NetforumItemVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["NetforumKey"] = this.netforumKey;
    data["NetforumType"] = this.netforumType;
    return data;
  }
}

export interface INetforumItemVm {
  netforumKey?: string;
  netforumType?: string | undefined;
}

export class NetforumItemVmQueryResponseWrapper
  implements INetforumItemVmQueryResponseWrapper {
  result?: NetforumItemVm;
  errorInfo?: ErrorInfo;
  errors?: StringStringKeyValuePair[] | undefined;

  constructor(data?: INetforumItemVmQueryResponseWrapper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data["Result"]
        ? NetforumItemVm.fromJS(_data["Result"])
        : <any>undefined;
      this.errorInfo = _data["ErrorInfo"]
        ? ErrorInfo.fromJS(_data["ErrorInfo"])
        : <any>undefined;
      if (Array.isArray(_data["Errors"])) {
        this.errors = [] as any;
        for (let item of _data["Errors"])
          this.errors!.push(StringStringKeyValuePair.fromJS(item));
      }
    }
  }

  static fromJS(data: any): NetforumItemVmQueryResponseWrapper {
    data = typeof data === "object" ? data : {};
    let result = new NetforumItemVmQueryResponseWrapper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
    data["ErrorInfo"] = this.errorInfo
      ? this.errorInfo.toJSON()
      : <any>undefined;
    if (Array.isArray(this.errors)) {
      data["Errors"] = [];
      for (let item of this.errors) data["Errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface INetforumItemVmQueryResponseWrapper {
  result?: NetforumItemVm;
  errorInfo?: ErrorInfo;
  errors?: StringStringKeyValuePair[] | undefined;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
